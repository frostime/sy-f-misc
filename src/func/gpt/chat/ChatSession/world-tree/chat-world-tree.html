<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chat Tree Visualization</title>
    <link rel="stylesheet" href="/plugins/sy-f-misc/styles/hspa-mini.css">
    <style>
        [x-cloak] { display: none !important; }

        /* ===== Page variables ===== */
        :root {
            --panel-width: 320px;
            --node-w: 100px;
            --node-h: 80px;
            --circle-size: 44px;
            --sep-size: 28px;

            --clr-user: #4caf50;
            --clr-user-bg: #e8f5e9;
            --clr-asst: #2196f3;
            --clr-asst-bg: #e3f2fd;
            --clr-sep: #9e9e9e;
            --clr-sep-bg: #f5f5f5;

            --edge-color: #b0b0b0;
            --edge-active: var(--c-accent, #4a90d9);
        }
        [data-theme-mode="dark"] {
            --clr-user-bg: #1b5e20;
            --clr-asst-bg: #0d47a1;
            --clr-sep-bg: #424242;
            --edge-color: #666;
        }

        /* ===== Main layout: tree + panel ===== */
        .main-layout {
            display: flex;
            flex: 1;
            min-height: 0;
            overflow: hidden;
        }
        .tree-viewport {
            flex: 1;
            overflow: auto;
            position: relative;
        }
        .tree-canvas {
            position: relative;
            min-width: 100%;
            min-height: 100%;
        }

        /* ===== Right detail panel ===== */
        .detail-panel {
            width: var(--panel-width);
            flex-shrink: 0;
            border-left: 1px solid var(--c-border, #e0e0e0);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            background: var(--c-bg, #fff);
        }
        .detail-panel-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: var(--sp-3, 12px) var(--sp-4, 16px);
            border-bottom: 1px solid var(--c-border, #e0e0e0);
            flex-shrink: 0;
        }
        .detail-panel-body {
            flex: 1;
            overflow-y: auto;
            padding: var(--sp-4, 16px);
        }
        .detail-panel-footer {
            padding: var(--sp-3, 12px) var(--sp-4, 16px);
            border-top: 1px solid var(--c-border, #e0e0e0);
            display: flex;
            flex-direction: column;
            gap: var(--sp-2, 8px);
            flex-shrink: 0;
        }

        .detail-section {
            margin-bottom: var(--sp-4, 16px);
        }
        .detail-section-title {
            font-size: var(--fs-sm, 13px);
            font-weight: 600;
            color: var(--c-fg-muted, #888);
            margin-bottom: var(--sp-2, 8px);
        }
        .detail-field {
            display: flex;
            gap: var(--sp-2, 8px);
            padding: 3px 0;
            font-size: var(--fs-sm, 13px);
            line-height: 1.5;
        }
        .detail-field-label {
            color: var(--c-fg-muted, #888);
            white-space: nowrap;
            min-width: 56px;
        }
        .detail-field-value {
            word-break: break-all;
        }

        .detail-preview {
            background: var(--c-surface, #f5f5f5);
            border: 1px solid var(--c-border, #e0e0e0);
            border-radius: var(--radius, 6px);
            padding: var(--sp-3, 12px);
            font-size: var(--fs-sm, 13px);
            line-height: 1.6;
            max-height: 200px;
            overflow-y: auto;
            white-space: pre-wrap;
            word-break: break-word;
        }

        .detail-empty {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            color: var(--c-fg-muted, #888);
            gap: var(--sp-2, 8px);
        }
        .detail-empty-icon {
            font-size: 36px;
            opacity: 0.4;
        }

        /* ===== Full content overlay ===== */
        .fullcontent-overlay {
            position: fixed;
            inset: 0;
            z-index: 200;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(0,0,0,0.4);
            animation: fadeIn 0.15s ease-out;
        }
        .fullcontent-card {
            width: min(720px, 90vw);
            max-height: 80vh;
            background: var(--c-bg, #fff);
            border-radius: var(--radius-lg, 10px);
            box-shadow: 0 8px 32px rgba(0,0,0,0.2);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            animation: slideUp 0.2s ease-out;
        }
        .fullcontent-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: var(--sp-3, 12px) var(--sp-4, 16px);
            border-bottom: 1px solid var(--c-border, #e0e0e0);
            flex-shrink: 0;
        }
        .fullcontent-body {
            flex: 1;
            overflow-y: auto;
            padding: var(--sp-4, 16px);
            font-size: var(--fs-sm, 13px);
            line-height: 1.7;
            white-space: pre-wrap;
            word-break: break-word;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to   { opacity: 1; }
        }
        @keyframes slideUp {
            from { opacity: 0; transform: translateY(12px); }
            to   { opacity: 1; transform: translateY(0); }
        }

        /* ===== SVG & Edges ===== */
        .tree-edges {
            position: absolute;
            top: 0; left: 0;
            pointer-events: none;
            overflow: visible;
        }
        .tree-edge {
            fill: none;
            stroke: var(--edge-color);
            stroke-width: 1.5;
            opacity: 0.55;
            transition: stroke 0.2s, stroke-width 0.2s, opacity 0.2s;
        }
        .tree-edge.active {
            stroke: var(--edge-active);
            stroke-width: 2.5;
            opacity: 1;
        }

        /* ===== Node ===== */
        .tree-node {
            position: absolute;
            display: flex;
            flex-direction: column;
            align-items: center;
            cursor: pointer;
            transition: filter 0.15s;
        }
        .tree-node:hover { filter: brightness(1.08); }
        .tree-node:hover .node-circle {
            transform: translateY(-2px);
            box-shadow: 0 2px 6px rgba(0,0,0,0.12);
        }
        .node-circle {
            width: var(--circle-size);
            height: var(--circle-size);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            font-weight: 700;
            border: 2.5px solid transparent;
            transition: transform 0.15s, box-shadow 0.2s, border-width 0.15s;
            position: relative;
            flex-shrink: 0;
        }
        .node-circle.user {
            background: var(--clr-user-bg); color: var(--clr-user); border-color: var(--clr-user);
        }
        .node-circle.assistant {
            background: var(--clr-asst-bg); color: var(--clr-asst); border-color: var(--clr-asst);
        }
        .node-circle.separator {
            width: var(--sep-size); height: var(--sep-size);
            background: var(--clr-sep-bg); color: var(--clr-sep); border-color: var(--clr-sep);
            font-size: 13px;
        }
        .node-circle.on-worldline { border-width: 3.5px; }
        .node-circle.selected {
            box-shadow: 0 0 0 4px rgba(74, 144, 217, 0.35);
        }

        .node-badge {
            position: absolute; top: -5px; right: -5px;
            min-width: 17px; height: 17px; padding: 0 4px;
            border-radius: 999px;
            background: var(--c-accent, #4a90d9); color: #fff;
            font-size: 10px; font-weight: 700;
            display: flex; align-items: center; justify-content: center;
        }
        .node-branch-badge {
            position: absolute; bottom: -5px; right: -5px;
            min-width: 17px; height: 17px; padding: 0 4px;
            border-radius: 999px;
            background: #ff9800; color: #fff;
            font-size: 10px; font-weight: 700;
            display: flex; align-items: center; justify-content: center;
        }
        .node-label {
            margin-top: 5px;
            font-size: var(--fs-xs, 11px);
            color: var(--c-fg-muted, #888);
            max-width: calc(var(--node-w) - 8px);
            text-align: center;
            overflow: hidden; text-overflow: ellipsis; white-space: nowrap;
        }

        /* Tooltip */
        .tree-node .node-tooltip {
            display: none;
            position: absolute;
            bottom: calc(100% + 8px); left: 50%; transform: translateX(-50%);
            background: var(--c-fg, #333); color: var(--c-bg, #fff);
            padding: 5px 10px; border-radius: var(--radius, 6px);
            font-size: var(--fs-xs, 11px);
            white-space: nowrap; max-width: 260px;
            overflow: hidden; text-overflow: ellipsis;
            z-index: 50; pointer-events: none;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
        }
        .tree-node:hover .node-tooltip { display: block; }

        /* Legend dots */
        .legend-dot {
            width: 10px; height: 10px; border-radius: 50%; flex-shrink: 0;
        }
        .legend-dot.user      { background: var(--clr-user); }
        .legend-dot.assistant  { background: var(--clr-asst); }
        .legend-dot.separator  { background: var(--clr-sep); }
        .legend-dot.worldline  { background: transparent; border: 2.5px solid var(--c-accent, #4a90d9); }

        /* Close button */
        .btn-close {
            width: 28px; height: 28px;
            display: flex; align-items: center; justify-content: center;
            border: none; background: transparent; cursor: pointer;
            border-radius: var(--radius, 6px); color: var(--c-fg-muted, #888); font-size: 16px;
        }
        .btn-close:hover { background: var(--c-surface, #f5f5f5); }
    </style>
</head>
<body class="page">
    <div x-data="chatTree()" x-init="init()" x-cloak style="display:flex;flex-direction:column;height:100%;">

        <!-- ===== Header ===== -->
        <div class="page-header" style="padding: var(--sp-2, 8px) var(--sp-4, 16px);">
            <div class="flex items-center gap-3">
                <span class="text-bold text-lg">Chat Tree</span>
                <div class="btn-group">
                    <button class="btn btn-sm btn-ghost" @click="fitView()">ÈÄÇÂ∫îÁ™óÂè£</button>
                    <button class="btn btn-sm btn-ghost" @click="centerRoot()">Â±Ö‰∏≠Ê†πËäÇÁÇπ</button>
                </div>
            </div>
            <span class="text-sm text-muted" x-text="infoText"></span>
        </div>

        <!-- ===== Main: tree + panel ===== -->
        <div class="main-layout">
            <!-- Tree -->
            <div class="tree-viewport" x-ref="viewport">
                <div class="tree-canvas" x-ref="canvas">
                    <svg class="tree-edges" x-ref="edges"></svg>
                    <div x-ref="nodes"></div>
                </div>
            </div>

            <!-- Detail panel (always visible) -->
            <div class="detail-panel">
                <div class="detail-panel-header">
                    <span class="text-bold">ËäÇÁÇπËØ¶ÊÉÖ</span>
                    <button class="btn-close" x-show="selectedNodeId" @click="closeDetail()" title="ÂÖ≥Èó≠">‚úï</button>
                </div>

                <!-- Empty state -->
                <div class="detail-panel-body" x-show="!detailNode">
                    <div class="detail-empty">
                        <div class="detail-empty-icon">üå≥</div>
                        <div>ÁÇπÂáªËäÇÁÇπÊü•ÁúãËØ¶ÊÉÖ</div>
                    </div>
                </div>

                <!-- Detail content -->
                <div class="detail-panel-body" x-show="detailNode" style="display:none;">
                    <template x-if="detailNode">
                        <div>
                            <!-- Âü∫Êú¨‰ø°ÊÅØ -->
                            <div class="detail-section">
                                <div class="detail-section-title">Âü∫Êú¨‰ø°ÊÅØ</div>
                                <div class="detail-field">
                                    <span class="detail-field-label">ID</span>
                                    <span class="detail-field-value" x-text="selectedNodeId"></span>
                                </div>
                                <div class="detail-field">
                                    <span class="detail-field-label">Á±ªÂûã</span>
                                    <span class="detail-field-value" x-text="detailNode.type === 'message' ? 'Ê∂àÊÅØ' : 'ÂàÜÈöîÁ¨¶'"></span>
                                </div>
                                <template x-if="detailNode.role">
                                    <div class="detail-field">
                                        <span class="detail-field-label">ËßíËâ≤</span>
                                        <span class="detail-field-value" x-text="detailNode.role === 'user' ? 'Áî®Êà∑' : 'Âä©Êâã'"></span>
                                    </div>
                                </template>
                                <template x-if="detailNode.author">
                                    <div class="detail-field">
                                        <span class="detail-field-label">‰ΩúËÄÖ</span>
                                        <span class="detail-field-value" x-text="detailNode.author"></span>
                                    </div>
                                </template>
                                <template x-if="detailNode.timestamp">
                                    <div class="detail-field">
                                        <span class="detail-field-label">Êó∂Èó¥</span>
                                        <span class="detail-field-value" x-text="new Date(detailNode.timestamp).toLocaleString()"></span>
                                    </div>
                                </template>
                            </div>

                            <!-- ÁªìÊûÑ‰ø°ÊÅØ -->
                            <div class="detail-section">
                                <div class="detail-section-title">ÁªìÊûÑ‰ø°ÊÅØ</div>
                                <div class="detail-field">
                                    <span class="detail-field-label">Áà∂ËäÇÁÇπ</span>
                                    <span class="detail-field-value" x-text="detailNode.parent || '(Ê†πËäÇÁÇπ)'"></span>
                                </div>
                                <div class="detail-field">
                                    <span class="detail-field-label">Â≠êËäÇÁÇπ</span>
                                    <span class="detail-field-value" x-text="detailNode.children.length + ' ‰∏™'"></span>
                                </div>
                                <template x-if="detailNode.versionCount > 1">
                                    <div class="detail-field">
                                        <span class="detail-field-label">ÁâàÊú¨Êï∞</span>
                                        <span class="detail-field-value" x-text="detailNode.versionCount"></span>
                                    </div>
                                </template>
                                <div class="detail-field">
                                    <span class="detail-field-label">‰∏ñÁïåÁ∫ø</span>
                                    <span class="detail-field-value" x-text="isOnWorldLine(selectedNodeId) ? '‚úì Âú®ÂΩìÂâç‰∏ñÁïåÁ∫ø' : '‚úó ‰∏çÂú®ÂΩìÂâç‰∏ñÁïåÁ∫ø'"></span>
                                </div>
                            </div>

                            <!-- ÂÜÖÂÆπÈ¢ÑËßà -->
                            <template x-if="detailNode.preview">
                                <div class="detail-section">
                                    <div class="detail-section-title">ÂÜÖÂÆπÈ¢ÑËßà</div>
                                    <div class="detail-preview" x-text="detailNode.preview"></div>
                                </div>
                            </template>
                        </div>
                    </template>
                </div>

                <!-- Actions -->
                <div class="detail-panel-footer" x-show="detailNode" style="display:none;">
                    <button class="btn btn-primary btn-sm w-full"
                        x-show="!isOnWorldLine(selectedNodeId) || canSwitchFrom(selectedNodeId)"
                        @click="switchToNode(selectedNodeId)">
                        ÂàáÊç¢Âà∞Ê≠§ÂàÜÊîØ
                    </button>
                    <button class="btn btn-sm w-full"
                        x-show="detailNode && detailNode.type === 'message'"
                        @click="showFullContent(selectedNodeId)">
                        Êü•ÁúãÂÆåÊï¥ÂÜÖÂÆπ
                    </button>
                </div>
            </div>
        </div>

        <!-- ===== Footer legend ===== -->
        <div class="page-footer page-footer--between" style="padding: var(--sp-2, 8px) var(--sp-4, 16px);">
            <div class="flex gap-4 text-xs text-muted">
                <span class="flex items-center gap-1"><span class="legend-dot user"></span> Áî®Êà∑</span>
                <span class="flex items-center gap-1"><span class="legend-dot assistant"></span> Âä©Êâã</span>
                <span class="flex items-center gap-1"><span class="legend-dot separator"></span> ÂàÜÈöîÁ¨¶</span>
                <span class="flex items-center gap-1"><span class="legend-dot worldline"></span> ‰∏ñÁïåÁ∫ø</span>
            </div>
            <span class="text-xs text-muted">ÁÇπÂáªËäÇÁÇπÊü•ÁúãËØ¶ÊÉÖ ¬∑ ÂèØÂàáÊç¢ÂàÜÊîØ</span>
        </div>

        <!-- ===== Full content overlay ===== -->
        <div class="fullcontent-overlay" x-show="fullContentVisible" style="display:none;"
            @click.self="fullContentVisible = false" @keydown.escape.window="fullContentVisible = false">
            <div class="fullcontent-card">
                <div class="fullcontent-header">
                    <div class="flex items-center gap-2">
                        <span class="text-bold">ÂÆåÊï¥ÂÜÖÂÆπ</span>
                        <span class="badge" x-show="fullContentRole"
                            :class="{'badge-success': fullContentRole === 'user', 'badge-info': fullContentRole === 'assistant'}"
                            x-text="fullContentRole === 'user' ? 'Áî®Êà∑' : 'Âä©Êâã'"></span>
                    </div>
                    <button class="btn-close" @click="fullContentVisible = false">‚úï</button>
                </div>
                <div class="fullcontent-body" x-text="fullContentText"></div>
            </div>
        </div>
    </div>

    <!-- ===== Application logic ===== -->
    <script>
    function chatTree() {
        return {
            // --- State ---
            treeData: null,
            selectedNodeId: null,
            _initialized: false,
            _positions: new Map(),
            _worldLineSet: new Set(),

            // Full content overlay
            fullContentVisible: false,
            fullContentText: '',
            fullContentRole: '',

            // Layout
            LAYOUT: Object.freeze({
                nodeWidth: 100, nodeHeight: 80,
                circleSize: 44, separatorSize: 28,
                levelGap: 100, siblingGap: 20, subtreeGap: 30,
                padding: 60
            }),

            // --- Computed ---
            get infoText() {
                if (!this.treeData) return '--';
                return 'ÊÄªËäÇÁÇπ: ' + Object.keys(this.treeData.nodes).length
                     + ' | ÂΩìÂâç‰∏ñÁïåÁ∫ø: ' + this.treeData.worldLine.length;
            },
            get detailNode() {
                if (!this.selectedNodeId || !this.treeData) return null;
                return this.treeData.nodes[this.selectedNodeId] || null;
            },

            // --- Init ---
            async init() {
                if (this._initialized) return;
                this._initialized = true;

                await new Promise(r => {
                    if (window.pluginSdk) return r();
                    window.addEventListener('pluginSdkReady', r, { once: true });
                });
                document.documentElement.setAttribute(
                    'data-theme-mode', window.pluginSdk?.themeMode || 'light'
                );

                if (window.pluginSdk?.getTreeData) {
                    const data = await window.pluginSdk.getTreeData();
                    this.renderTree(data);
                }

                window.addEventListener('treeDataUpdate', (e) => this.renderTree(e.detail));
                window.renderTree = (data) => this.renderTree(data);
            },

            // --- Helpers ---
            isOnWorldLine(id) { return this._worldLineSet.has(id); },
            canSwitchFrom(id) {
                if (!this.treeData) return false;
                const n = this.treeData.nodes[id];
                return n && n.children.length > 1;
            },
            escapeHtml(str) {
                if (!str) return '';
                const map = { '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;' };
                return str.replace(/[&<>"']/g, c => map[c]);
            },

            // ================================================================
            //  Reingold-Tilford Layout
            // ================================================================
            buildLayoutTree(nodes, rootId) {
                if (!rootId || !nodes[rootId]) return null;
                function build(id, depth) {
                    const node = nodes[id];
                    if (!node) return null;
                    const ln = { id, children: [], x: 0, y: depth, mod: 0, thread: null, ancestor: null, change: 0, shift: 0 };
                    ln.ancestor = ln;
                    for (const cid of node.children) { const c = build(cid, depth + 1); if (c) ln.children.push(c); }
                    return ln;
                }
                return build(rootId, 0);
            },
            firstWalk(node, siblings = [], index = 0) {
                const L = this.LAYOUT;
                if (node.children.length === 0) {
                    node.x = index > 0 ? siblings[index - 1].x + L.nodeWidth + L.siblingGap : 0;
                } else {
                    let da = node.children[0];
                    for (let i = 0; i < node.children.length; i++) {
                        this.firstWalk(node.children[i], node.children, i);
                        da = this._apportion(node.children[i], da, node.children, i);
                    }
                    this._executeShifts(node);
                    const mid = (node.children[0].x + node.children[node.children.length - 1].x) / 2;
                    if (index > 0) { node.x = siblings[index - 1].x + L.nodeWidth + L.siblingGap; node.mod = node.x - mid; }
                    else { node.x = mid; }
                }
            },
            _apportion(node, da, siblings, index) {
                if (index <= 0) return da;
                const L = this.LAYOUT, ls = siblings[index - 1];
                let vir = node, vor = node, vil = ls, vol = siblings[0];
                let sir = node.mod, sor = node.mod, sil = vil.mod, sol = vol.mod;
                while (this._nextRight(vil) && this._nextLeft(vir)) {
                    vil = this._nextRight(vil); vir = this._nextLeft(vir);
                    vol = this._nextLeft(vol); vor = this._nextRight(vor);
                    vor.ancestor = node;
                    const sh = (vil.x + sil) - (vir.x + sir) + L.nodeWidth + L.subtreeGap;
                    if (sh > 0) { const a = siblings.includes(vil.ancestor) ? vil.ancestor : da; this._moveSubtree(a, node, sh, siblings); sir += sh; sor += sh; }
                    sil += vil.mod; sir += vir.mod; sol += vol.mod; sor += vor.mod;
                }
                if (this._nextRight(vil) && !this._nextRight(vor)) { vor.thread = this._nextRight(vil); vor.mod += sil - sor; }
                if (this._nextLeft(vir) && !this._nextLeft(vol)) { vol.thread = this._nextLeft(vir); vol.mod += sir - sol; da = node; }
                return da;
            },
            _nextLeft(n) { return n.children.length > 0 ? n.children[0] : n.thread; },
            _nextRight(n) { return n.children.length > 0 ? n.children[n.children.length - 1] : n.thread; },
            _moveSubtree(wl, wr, shift, siblings) {
                const s = siblings.indexOf(wr) - siblings.indexOf(wl);
                if (s > 0) { wr.change -= shift / s; wr.shift += shift; wl.change += shift / s; wr.x += shift; wr.mod += shift; }
            },
            _executeShifts(node) {
                let shift = 0, change = 0;
                for (let i = node.children.length - 1; i >= 0; i--) {
                    const c = node.children[i]; c.x += shift; c.mod += shift;
                    change += c.change || 0; shift += (c.shift || 0) + change;
                }
            },
            secondWalk(node, modSum = 0, minX = { value: Infinity }) {
                node.x += modSum; minX.value = Math.min(minX.value, node.x);
                for (const c of node.children) this.secondWalk(c, modSum + node.mod, minX);
                return minX.value;
            },
            collectPositions(node, offsetX) {
                const L = this.LAYOUT;
                this._positions.set(node.id, { x: node.x + offsetX + L.padding, y: node.y * L.levelGap + L.padding });
                for (const c of node.children) this.collectPositions(c, offsetX);
            },
            layoutTree(data) {
                this._positions.clear();
                if (!data?.rootId || !data.nodes[data.rootId]) return;
                const root = this.buildLayoutTree(data.nodes, data.rootId);
                if (!root) return;
                this.firstWalk(root, [], 0);
                const minX = this.secondWalk(root);
                this.collectPositions(root, -minX);
            },

            // ================================================================
            //  Rendering
            // ================================================================
            getNodeCenter(id, nodes) {
                const pos = this._positions.get(id);
                if (!pos) return null;
                const size = nodes[id]?.type === 'separator' ? this.LAYOUT.separatorSize : this.LAYOUT.circleSize;
                return { x: pos.x, y: pos.y + size / 2 };
            },

            renderTree(data) {
                const $e = this.$refs.edges, $n = this.$refs.nodes, $c = this.$refs.canvas, $v = this.$refs.viewport;
                if (!data) {
                    $n.innerHTML = '<div style="position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);text-align:center;color:var(--c-fg-muted,#888)">'
                        + '<div style="font-size:48px;opacity:0.4">üå≥</div><div>ÊöÇÊó†Êï∞ÊçÆ</div></div>';
                    $e.innerHTML = ''; return;
                }

                this.treeData = data;
                this._worldLineSet = new Set(data.worldLine);
                this.selectedNodeId = null;
                this.layoutTree(data);

                const { nodes } = data;
                const wl = this._worldLineSet, L = this.LAYOUT;

                // Canvas size
                let maxX = 0, maxY = 0;
                for (const [, pos] of this._positions) { maxX = Math.max(maxX, pos.x + L.nodeWidth / 2); maxY = Math.max(maxY, pos.y + L.nodeHeight); }
                const cw = maxX + L.padding, ch = maxY + L.padding;
                $c.style.width = cw + 'px'; $c.style.height = ch + 'px';
                $e.setAttribute('width', cw); $e.setAttribute('height', ch);
                $e.setAttribute('viewBox', '0 0 ' + cw + ' ' + ch);

                // Edges
                let eh = '';
                for (const [id, node] of Object.entries(nodes)) {
                    const pc = this.getNodeCenter(id, nodes); if (!pc) continue;
                    for (const cid of node.children) {
                        const cc = this.getNodeCenter(cid, nodes); if (!cc) continue;
                        const act = wl.has(id) && wl.has(cid);
                        eh += '<path class="tree-edge' + (act ? ' active' : '') + '" d="M ' + pc.x + ' ' + pc.y
                            + ' C ' + pc.x + ' ' + (pc.y + (cc.y - pc.y) * 0.4) + ', '
                            + cc.x + ' ' + (pc.y + (cc.y - pc.y) * 0.6) + ', ' + cc.x + ' ' + cc.y + '"/>';
                    }
                }
                $e.innerHTML = eh;

                // Nodes
                let nh = '';
                for (const [id, node] of Object.entries(nodes)) {
                    const pos = this._positions.get(id); if (!pos) continue;
                    const onWL = wl.has(id), isSep = node.type === 'separator';
                    const rc = node.role || 'separator';
                    const icon = node.role === 'user' ? 'U' : node.role === 'assistant' ? 'A' : '‚Äî';
                    const label = node.preview ? node.preview.slice(0, 25) : (isSep ? 'ÂàÜÈöîÁ¨¶' : '');
                    const tip = node.role ? (node.role === 'user' ? 'Áî®Êà∑' : 'Âä©Êâã') + ': ' + (node.preview || '').slice(0, 50) : 'ÂàÜÈöîÁ¨¶';
                    let badges = '';
                    if (node.versionCount > 1) badges += '<div class="node-badge">' + node.versionCount + '</div>';
                    if (node.children.length > 1) badges += '<div class="node-branch-badge">' + node.children.length + '</div>';
                    nh += '<div class="tree-node" data-id="' + id + '" style="left:' + (pos.x - L.nodeWidth / 2) + 'px;top:' + pos.y + 'px;width:' + L.nodeWidth + 'px;">'
                        + '<div class="node-tooltip">' + this.escapeHtml(tip) + '</div>'
                        + '<div class="node-circle ' + rc + (onWL ? ' on-worldline' : '') + '">' + icon + badges + '</div>'
                        + '<div class="node-label" title="' + this.escapeHtml(label) + '">' + this.escapeHtml(label) + '</div></div>';
                }
                $n.innerHTML = nh;

                // Click delegation
                $n.onclick = (e) => {
                    const el = e.target.closest('.tree-node');
                    if (el) { e.stopPropagation(); this.selectNode(el.getAttribute('data-id')); }
                };

                requestAnimationFrame(() => this.fitView());
            },

            // ================================================================
            //  Interactions
            // ================================================================
            selectNode(id) {
                if (!this.treeData?.nodes?.[id]) return;
                this.$refs.nodes.querySelectorAll('.node-circle.selected').forEach(el => el.classList.remove('selected'));
                const el = this.$refs.nodes.querySelector('[data-id="' + id + '"] .node-circle');
                if (el) el.classList.add('selected');
                this.selectedNodeId = id;
            },
            closeDetail() {
                if (this.selectedNodeId) {
                    const el = this.$refs.nodes.querySelector('[data-id="' + this.selectedNodeId + '"] .node-circle');
                    if (el) el.classList.remove('selected');
                }
                this.selectedNodeId = null;
            },
            findLeafFrom(nodeId) {
                const nodes = this.treeData?.nodes; if (!nodes) return nodeId;
                let cur = nodeId;
                while (true) {
                    const n = nodes[cur]; if (!n || n.children.length === 0) break;
                    const wc = n.children.find(c => this._worldLineSet.has(c));
                    cur = wc || n.children[0];
                }
                return cur;
            },
            switchToNode(id) {
                const leafId = this.findLeafFrom(id);
                if (window.pluginSdk?.switchWorldLine) window.pluginSdk.switchWorldLine(leafId);
                else window.pluginSdk?.showMessage?.('Â∑≤ËØ∑Ê±ÇÂàáÊç¢‰∏ñÁïåÁ∫ø');
            },
            async showFullContent(id) {
                if (!id) return;
                this.fullContentRole = this.treeData?.nodes?.[id]?.role || '';
                if (window.pluginSdk?.getFullContent) {
                    try {
                        this.fullContentText = await window.pluginSdk.getFullContent(id);
                    } catch (e) {
                        this.fullContentText = 'Âä†ËΩΩÂ§±Ë¥•: ' + e.message;
                    }
                } else {
                    this.fullContentText = this.treeData?.nodes?.[id]?.preview || '(Êó†ÂÜÖÂÆπ)';
                }
                this.fullContentVisible = true;
            },
            fitView() {
                const vp = this.$refs.viewport, cv = this.$refs.canvas;
                if (!vp || !cv) return;
                vp.scrollTo({ left: Math.max(0, (cv.offsetWidth - vp.offsetWidth) / 2), top: 0, behavior: 'smooth' });
            },
            centerRoot() {
                if (!this.treeData?.rootId) return;
                const pos = this._positions.get(this.treeData.rootId);
                if (!pos) return;
                const vp = this.$refs.viewport;
                vp.scrollTo({ left: Math.max(0, pos.x - vp.offsetWidth / 2), top: 0, behavior: 'smooth' });
            },
        };
    }
    </script>
    <script src="/plugins/sy-f-misc/scripts/alpine.min.js" defer></script>
</body>
</html>
