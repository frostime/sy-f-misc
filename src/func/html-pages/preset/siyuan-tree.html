<!DOCTYPE html>
<html lang="zh-CN">
<!--
    SiYuan File Viewer ‚Äî Alpine.js rewrite
    Based on HSPA SKILL v2.2.0 + Alpine.js + hspa-mini.css

    NOTE: The file tree uses x-html + event delegation because Alpine has
    no native recursive template support. This is the pragmatic approach
    for tree structures. Alpine manages all other state declaratively.
-->
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SiYuan File Viewer</title>
    <link rel="stylesheet" href="/plugins/sy-f-misc/styles/hspa-mini.css">
    <style>
        /* MUST: prevent FOUC before Alpine initializes */
        [x-cloak] { display: none !important; }

        /* ===== Sidebar + content layout ===== */
        .app-layout {
            display: flex;
            flex: 1;
            min-height: 0;
            overflow: hidden;
        }

        /* Sidebar */
        .sidebar {
            width: var(--sidebar-width, 360px);
            background: var(--c-surface, #f5f5f7);
            border-right: 1px solid var(--c-border, #e0e0e0);
            display: flex;
            flex-direction: column;
            flex-shrink: 0;
        }
        .sidebar-toolbar {
            padding: var(--sp-2, 8px);
            border-bottom: 1px solid var(--c-border, #e0e0e0);
            display: flex;
            gap: var(--sp-1, 4px);
        }
        .sidebar-tree {
            flex: 1;
            overflow-y: auto;
            padding: var(--sp-2, 8px) 0;
        }

        /* Resize handle */
        .resize-handle {
            width: 4px;
            cursor: col-resize;
            flex-shrink: 0;
            transition: background 0.2s;
            margin-left: -2px;
            z-index: 10;
        }
        .resize-handle:hover,
        .resize-handle.active {
            background: var(--c-accent, #d23f31);
        }

        /* Content area */
        .content-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            position: relative;
        }
        .content-header {
            padding: var(--sp-3, 12px) var(--sp-6, 24px);
            border-bottom: 1px solid var(--c-border, #e0e0e0);
            font-weight: 600;
            font-size: var(--fs-lg, 16px);
            flex-shrink: 0;
            padding-right: 60px; /* space for menu */
        }
        .content-body {
            flex: 1;
            overflow-y: auto;
            padding: var(--sp-6, 24px);
        }
        .content-body pre {
            white-space: pre-wrap;
            word-wrap: break-word;
            font-family: var(--font-family-code, "Consolas", "Monaco", monospace);
            font-size: var(--fs, 14px);
            color: var(--c-fg, #333);
            margin: 0;
            line-height: 1.6;
        }

        /* ===== Tree node styles ===== */
        .tree-node { user-select: none; }
        .node-header {
            display: flex;
            align-items: center;
            padding: 4px 8px;
            cursor: pointer;
            transition: background 0.1s;
        }
        .node-header:hover { background: var(--c-surface-hover, #e8e8e8); }
        .node-header.active { background: var(--c-accent-bg, #ffe8e6); color: var(--c-accent, #d23f31); }

        .toggle-icon {
            width: 20px; height: 20px;
            display: flex; align-items: center; justify-content: center;
            margin-right: 4px;
            color: var(--c-fg-muted, #666);
            font-size: var(--fs-sm, 12px);
            transition: transform 0.2s;
        }
        .expanded > .node-header > .toggle-icon { transform: rotate(90deg); }
        .node-icon { margin-right: 6px; }
        .node-name {
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            flex: 1;
        }
        .children-container { padding-left: 18px; display: none; }
        .expanded > .children-container { display: block; }

        .loading-text { color: var(--c-fg-muted, #999); font-size: var(--fs-sm, 12px); padding-left: 24px; }
        .error-text   { color: var(--c-error, #ff4444); font-size: var(--fs-sm, 12px); padding-left: 24px; }

        /* ===== Floating menu ===== */
        .float-menu {
            position: absolute;
            top: 10px; right: 20px;
            z-index: var(--z-dropdown, 50);
        }
        .menu-dropdown {
            position: absolute;
            top: 36px; right: 0;
            background: var(--c-bg, #fff);
            border: 1px solid var(--c-border, #e0e0e0);
            border-radius: var(--radius, 6px);
            box-shadow: var(--shadow, 0 2px 10px rgba(0,0,0,0.1));
            min-width: 140px;
            display: flex;
            flex-direction: column;
            padding: 4px 0;
        }
        .menu-item {
            padding: 8px 16px;
            cursor: pointer;
            text-align: left;
            background: none; border: none;
            color: var(--c-fg, #333);
            font-size: var(--fs-sm, 12px);
            display: flex; align-items: center; gap: 8px;
        }
        .menu-item:hover { background: var(--c-surface-hover, #e8e8e8); }
        .menu-item:disabled { color: var(--c-fg-muted, #888); cursor: not-allowed; opacity: 0.6; }

        /* ===== Edit modal ===== */
        .modal-overlay {
            position: fixed; inset: 0;
            background: rgba(0,0,0,0.5);
            display: flex; align-items: center; justify-content: center;
            z-index: var(--z-modal, 200);
        }
        .modal {
            background: var(--c-bg, #fff);
            padding: var(--sp-5, 20px);
            border-radius: var(--radius-lg, 10px);
            width: 80%; max-width: 800px; height: 80%;
            display: flex; flex-direction: column;
            box-shadow: 0 4px 20px rgba(0,0,0,0.2);
        }
        .modal-body { flex: 1; margin: var(--sp-4, 16px) 0; overflow: hidden; }
        .modal-body textarea {
            width: 100%; height: 100%; resize: none;
            padding: var(--sp-3, 12px);
            border: 1px solid var(--c-border, #e0e0e0);
            border-radius: var(--radius, 6px);
            background: var(--c-surface, #f5f5f5);
            color: var(--c-fg, #333);
            font-family: var(--font-family-code, "Consolas", "Monaco", monospace);
            font-size: var(--fs, 14px);
            outline: none;
        }
        .modal-body textarea:focus { border-color: var(--c-accent, #d23f31); }

        /* ===== Toast ===== */
        .toast-container {
            position: fixed; top: 20px; right: 20px;
            z-index: 10000;
            display: flex; flex-direction: column; gap: 10px;
            pointer-events: none;
        }
        .toast {
            background: var(--c-bg, #fff);
            color: var(--c-fg, #333);
            padding: 12px 20px;
            border-radius: var(--radius, 6px);
            box-shadow: var(--shadow-lg, 0 4px 12px rgba(0,0,0,0.15));
            border-left: 4px solid var(--c-accent, #d23f31);
            min-width: 200px; max-width: 400px;
            animation: toast-in 0.3s ease-out;
            pointer-events: auto;
            display: flex; align-items: center; gap: 10px;
        }
        .toast.success { border-left-color: var(--c-success, #34a853); }
        .toast.error   { border-left-color: var(--c-error, #ff4444); }
        .toast.warning { border-left-color: var(--c-warning, #fbbc04); }
        .toast.info    { border-left-color: var(--c-accent, #d23f31); }

        @keyframes toast-in {
            from { transform: translateX(400px); opacity: 0; }
            to   { transform: translateX(0); opacity: 1; }
        }
        .toast.hiding {
            animation: toast-out 0.3s ease-out forwards;
        }
        @keyframes toast-out {
            from { transform: translateX(0); opacity: 1; }
            to   { transform: translateX(400px); opacity: 0; }
        }
    </style>
</head>
<body class="page">
    <div x-data="fileViewer()" x-init="init()" x-cloak style="display:flex;flex-direction:column;height:100%;">

        <!-- ===== Layout: sidebar + content ===== -->
        <div class="app-layout">

            <!-- Sidebar -->
            <div class="sidebar">
                <div class="sidebar-toolbar">
                    <input class="input flex-1" x-model="rootPath"
                        @keydown.enter="refreshTree()" placeholder="Root Path">
                    <button class="btn btn-sm" @click="refreshTree()">Go</button>
                </div>
                <div class="sidebar-tree" x-ref="tree"></div>
            </div>

            <!-- Resize handle -->
            <div class="resize-handle" x-ref="resizeHandle"></div>

            <!-- Content area -->
            <div class="content-area">
                <!-- Float menu -->
                <div class="float-menu">
                    <button class="btn btn-icon btn-sm" @click.stop="menuOpen = !menuOpen" title="ËèúÂçï">
                        <svg viewBox="0 0 24 24" width="18" height="18" stroke="currentColor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round">
                            <circle cx="12" cy="12" r="1"></circle>
                            <circle cx="19" cy="12" r="1"></circle>
                            <circle cx="5" cy="12" r="1"></circle>
                        </svg>
                    </button>
                    <div class="menu-dropdown" x-show="menuOpen" @click.outside="menuOpen = false"
                        x-transition style="display:none;">
                        <button class="menu-item" :disabled="!selectedFile" @click="handleDownload()">
                            <span>üì•</span> ‰∏ãËΩΩÊñá‰ª∂
                        </button>
                        <button class="menu-item" :disabled="!selectedFile || isImage" @click="handleCopyText()">
                            <span>üìÑ</span> Â§çÂà∂ÊñáÊú¨
                        </button>
                        <button class="menu-item" :disabled="!selectedFile || !isImage" @click="handleCopyImage()">
                            <span>üñºÔ∏è</span> Â§çÂà∂ÂõæÁâá
                        </button>
                        <div style="height:1px; background:var(--c-border,#e0e0e0); margin:4px 0;"></div>
                        <button class="menu-item" :disabled="!isEditable" @click="handleEdit()">
                            <span>‚úèÔ∏è</span> ÁºñËæëÊñá‰ª∂
                        </button>
                    </div>
                </div>

                <div class="content-header" x-text="contentTitle"></div>
                <div class="content-body">
                    <template x-if="!selectedFile && !contentLoading">
                        <div class="empty-state"><div>ËØ∑‰ªéÂ∑¶‰æßÈÄâÊã©Êñá‰ª∂‰ª•Êü•ÁúãÂÜÖÂÆπ</div></div>
                    </template>
                    <template x-if="contentLoading">
                        <div class="loading-text" style="margin-top:20px">Ê≠£Âú®ËØªÂèñÊñá‰ª∂...</div>
                    </template>
                    <div x-show="!contentLoading && selectedFile" x-html="contentHTML" style="display:none;"></div>
                </div>
            </div>
        </div>

        <!-- ===== Edit modal (x-show for timing safety) ===== -->
        <div class="modal-overlay" x-show="editModalOpen" style="display:none;"
            @keydown.escape.window="editModalOpen = false">
            <div class="modal" @click.stop>
                <div class="flex-between">
                    <span class="text-bold text-lg" x-text="'ÁºñËæë: ' + editFileName"></span>
                    <button class="btn btn-icon" @click="editModalOpen = false" style="font-size:20px;">√ó</button>
                </div>
                <div class="modal-body">
                    <textarea x-ref="editTextarea" spellcheck="false"></textarea>
                </div>
                <div class="flex justify-end gap-2">
                    <button class="btn" @click="editModalOpen = false">ÂèñÊ∂à</button>
                    <button class="btn btn-primary" @click="handleSaveEdit()" x-text="saving ? '‰øùÂ≠ò‰∏≠...' : 'Ë¶ÜÁõñ'" :disabled="saving"></button>
                </div>
            </div>
        </div>

        <!-- ===== Toast container ===== -->
        <div class="toast-container" x-ref="toastContainer"></div>
    </div>

    <!-- ===== Application logic ===== -->
    <script>
    function fileViewer() {
        return {
            // ‚îÄ‚îÄ‚îÄ State ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
            rootPath: '/data',
            selectedFile: null,         // current file path
            contentTitle: 'Êú™ÈÄâÊã©Êñá‰ª∂',
            contentHTML: '',
            contentLoading: false,
            menuOpen: false,
            _initialized: false,

            // Edit modal
            editModalOpen: false,
            editFileName: '',
            saving: false,

            // ‚îÄ‚îÄ‚îÄ Computed ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
            get isImage() {
                return this.selectedFile && /\.(png|jpg|jpeg|gif|bmp|svg|webp)$/i.test(this.selectedFile);
            },
            get isEditable() {
                return this.selectedFile && this._isEditableFile(this.selectedFile);
            },

            // ‚îÄ‚îÄ‚îÄ Init ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
            async init() {
                // Guard: SDK may be injected multiple times
                if (this._initialized) return;
                this._initialized = true;

                // Wait for SDK injection
                await new Promise(r => {
                    if (window.pluginSdk) return r();
                    window.addEventListener('pluginSdkReady', r, { once: true });
                });

                // Enable dark mode CSS
                document.documentElement.setAttribute(
                    'data-theme-mode', window.pluginSdk.themeMode || 'light'
                );

                // Load saved settings
                const config = await this._loadSettings();
                if (config.rootPath) this.rootPath = config.rootPath;

                // Render initial tree
                await this._renderLevel(this.rootPath, this.$refs.tree);

                // Setup resize handle
                this._initResize();

                // Setup tree event delegation
                this.$refs.tree.addEventListener('click', (e) => this._handleTreeClick(e));

                // Restore last open file
                if (config.lastOpenFile) {
                    this.selectedFile = config.lastOpenFile;
                    await this._loadContent(config.lastOpenFile);
                }
            },

            // ‚îÄ‚îÄ‚îÄ Tree rendering (x-html not suitable for recursive lazy trees) ‚îÄ‚îÄ‚îÄ
            async _renderLevel(path, container) {
                container.innerHTML = '<div class="loading-text">Âä†ËΩΩ‰∏≠...</div>';
                const nodes = await this._listDir(path);
                container.innerHTML = '';

                if (!nodes) { container.innerHTML = '<div class="error-text">Âä†ËΩΩÂ§±Ë¥•</div>'; return; }
                if (nodes.length === 0) { container.innerHTML = '<div class="loading-text">Á©∫ÁõÆÂΩï</div>'; return; }

                nodes.forEach(node => {
                    const wrap = document.createElement('div');
                    wrap.className = 'tree-node';

                    const header = document.createElement('div');
                    header.className = 'node-header';
                    header.dataset.path = node.path;
                    header.dataset.leaf = node.leaf ? '1' : '0';

                    const toggle = document.createElement('div');
                    toggle.className = 'toggle-icon';
                    if (!node.leaf) toggle.textContent = '‚ñ∂';
                    header.appendChild(toggle);

                    const icon = document.createElement('span');
                    icon.className = 'node-icon';
                    icon.textContent = node.leaf ? 'üìÑ' : 'üìÅ';
                    header.appendChild(icon);

                    const name = document.createElement('span');
                    name.className = 'node-name';
                    name.textContent = node.name;
                    header.appendChild(name);

                    wrap.appendChild(header);

                    if (!node.leaf) {
                        const children = document.createElement('div');
                        children.className = 'children-container';
                        wrap.appendChild(children);
                    }

                    container.appendChild(wrap);
                });
            },

            async _handleTreeClick(e) {
                const header = e.target.closest('.node-header');
                if (!header) return;

                const path = header.dataset.path;
                const isLeaf = header.dataset.leaf === '1';
                const wrap = header.parentElement;

                if (isLeaf) {
                    // Select file
                    this.$refs.tree.querySelectorAll('.node-header.active').forEach(h => h.classList.remove('active'));
                    header.classList.add('active');
                    this.selectedFile = path;
                    this._saveSettings({ rootPath: this.rootPath, lastOpenFile: path });
                    await this._loadContent(path);
                } else {
                    // Toggle folder
                    const children = wrap.querySelector('.children-container');
                    if (!children) return;

                    if (wrap.classList.contains('expanded')) {
                        wrap.classList.remove('expanded');
                    } else {
                        wrap.classList.add('expanded');
                        if (children.children.length === 0) {
                            await this._renderLevel(path, children);
                        }
                    }
                }
            },

            async refreshTree() {
                const p = this.rootPath.trim();
                if (!p) { this._toast('Ë∑ØÂæÑ‰∏çËÉΩ‰∏∫Á©∫', 'warning'); return; }
                this.rootPath = p;
                this._saveSettings({ rootPath: p, lastOpenFile: this.selectedFile });
                await this._renderLevel(p, this.$refs.tree);
            },

            // ‚îÄ‚îÄ‚îÄ Content loading ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
            async _loadContent(path) {
                this.contentLoading = true;
                this.contentTitle = path.split('/').pop();
                try {
                    const result = await this._getFile(path);
                    if (result.isHTML) {
                        this.contentHTML = result.content;
                    } else {
                        this.contentHTML = '<pre>' + this._escapeHtml(result.content) + '</pre>';
                    }
                } catch (e) {
                    this.contentHTML = '<div class="empty-state" style="color:var(--c-error)">Âä†ËΩΩÂ§±Ë¥•: ' + this._escapeHtml(e.message) + '</div>';
                } finally {
                    this.contentLoading = false;
                }
            },

            // ‚îÄ‚îÄ‚îÄ Menu actions ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
            async handleDownload() {
                if (!this.selectedFile) return;
                try {
                    const res = await window.pluginSdk.loadBlob(this.selectedFile);
                    if (!res.ok) throw new Error('ËØªÂèñÊñá‰ª∂Â§±Ë¥•');
                    const url = URL.createObjectURL(res.data);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = this.selectedFile.split('/').pop();
                    a.click();
                    URL.revokeObjectURL(url);
                    this._toast('Êñá‰ª∂Â∑≤‰∏ãËΩΩ', 'success');
                } catch (e) { this._toast('‰∏ãËΩΩÂ§±Ë¥•: ' + e.message, 'error'); }
                this.menuOpen = false;
            },

            async handleCopyText() {
                if (!this.selectedFile) return;
                try {
                    const res = await this._getFile(this.selectedFile);
                    if (res.isHTML) { this._toast('ÂΩìÂâçÊñá‰ª∂‰∏çÊòØÁ∫ØÊñáÊú¨', 'warning'); return; }
                    await navigator.clipboard.writeText(res.content);
                    this._toast('Â∑≤Â§çÂà∂Âà∞Ââ™Ë¥¥Êùø', 'success');
                } catch (e) { this._toast('Â§çÂà∂Â§±Ë¥•: ' + e.message, 'error'); }
                this.menuOpen = false;
            },

            async handleCopyImage() {
                if (!this.selectedFile) return;
                try {
                    const blobRes = await window.pluginSdk.loadBlob(this.selectedFile);
                    if (!blobRes.ok) throw new Error('Âä†ËΩΩÂõæÁâáÂ§±Ë¥•');
                    if (!blobRes.data.type.startsWith('image/')) { this._toast('ÂΩìÂâçÊñá‰ª∂‰∏çÊòØÂõæÁâá', 'error'); return; }

                    const img = new Image();
                    const objectURL = URL.createObjectURL(blobRes.data);
                    await new Promise((resolve, reject) => { img.onload = resolve; img.onerror = reject; img.src = objectURL; });

                    const canvas = document.createElement('canvas');
                    canvas.width = img.width; canvas.height = img.height;
                    canvas.getContext('2d').drawImage(img, 0, 0);
                    URL.revokeObjectURL(objectURL);

                    const pngBlob = await new Promise(r => canvas.toBlob(r, 'image/png'));
                    await navigator.clipboard.write([new ClipboardItem({ 'image/png': pngBlob })]);
                    this._toast('ÂõæÁâáÂ∑≤Â§çÂà∂Âà∞Ââ™Ë¥¥Êùø', 'success');
                } catch (e) { this._toast('Â§çÂà∂ÂõæÁâáÂ§±Ë¥•: ' + e.message, 'error'); }
                this.menuOpen = false;
            },

            async handleEdit() {
                const path = this.selectedFile;
                if (!path || !this._isEditableFile(path)) return;

                try {
                    const blobRes = await window.pluginSdk.loadBlob(path);
                    if (!blobRes.ok) throw new Error('ËØªÂèñÊñá‰ª∂Â§±Ë¥•');
                    const mime = blobRes.data.type || '';
                    if (mime && !mime.startsWith('text/') && mime !== 'application/json' && mime !== 'application/javascript' && mime !== 'application/xml') {
                        this._toast('Ê≠§Êñá‰ª∂‰∏çÊòØÁ∫ØÊñáÊú¨Ê†ºÂºè', 'error'); return;
                    }

                    const content = await blobRes.data.text();
                    this.editFileName = path.split('/').pop();
                    this.editModalOpen = true;
                    this.menuOpen = false;
                    // Set textarea value after modal is visible
                    this.$nextTick(() => { this.$refs.editTextarea.value = content; });
                } catch (e) { this._toast('ÊâìÂºÄÁºñËæëÂô®Â§±Ë¥•: ' + e.message, 'error'); }
            },

            async handleSaveEdit() {
                const path = this.selectedFile;
                const content = this.$refs.editTextarea.value;

                const doSave = async () => {
                    try {
                        this.saving = true;
                        const blob = new Blob([content], { type: 'text/plain' });
                        if (window.pluginSdk.saveBlob) {
                            await window.pluginSdk.saveBlob(path, blob);
                        } else {
                            throw new Error('saveBlob ÊñπÊ≥ï‰∏çÂèØÁî®');
                        }
                        await this._loadContent(path);
                        this.editModalOpen = false;
                        this._toast('‰øùÂ≠òÊàêÂäü', 'success');
                    } catch (e) { this._toast('‰øùÂ≠òÂ§±Ë¥•: ' + e.message, 'error'); }
                    finally { this.saving = false; }
                };

                // JSON validation
                if (path.endsWith('.json')) {
                    try { JSON.parse(content); }
                    catch (e) {
                        window.pluginSdk.confirm('Âº∫Âà∂‰øùÂ≠ò', 'JSON Ê†ºÂºèÊ†°È™åÂ§±Ë¥•ÔºåÊòØÂê¶Âº∫Âà∂‰øùÂ≠òÔºü\nÈîôËØØ: ' + e.message, () => doSave());
                        return;
                    }
                }
                doSave();
            },

            // ‚îÄ‚îÄ‚îÄ Resize handle ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
            _initResize() {
                let resizing = false;
                const handle = this.$refs.resizeHandle;
                handle.addEventListener('mousedown', (e) => { resizing = true; handle.classList.add('active'); document.body.style.cursor = 'col-resize'; e.preventDefault(); });
                document.addEventListener('mousemove', (e) => { if (!resizing) return; const w = Math.min(600, Math.max(200, e.clientX)); document.documentElement.style.setProperty('--sidebar-width', w + 'px'); });
                document.addEventListener('mouseup', () => { if (resizing) { resizing = false; handle.classList.remove('active'); document.body.style.cursor = ''; } });
            },

            // ‚îÄ‚îÄ‚îÄ SiYuan API wrappers ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
            _parseSyPath(path) {
                const docPath = path.substring(6, path.length - 3);
                const docId = docPath.split('/').pop();
                const notebookId = docPath.split('/').shift();
                const notebooks = window.pluginSdk.lsNotebooks();
                let nb = notebooks.find(n => n.id === notebookId);
                if (!nb) nb = { name: 'Êú™Áü•Á¨îËÆ∞Êú¨', id: notebookId, closed: true };
                return { docId, notebook: nb };
            },

            async _listDir(path) {
                try {
                    const res = await window.pluginSdk.request('/api/file/readDir', { path });
                    if (!res.ok) throw new Error(res.msg || 'Êú™Áü•ÈîôËØØ');
                    return res.data.map(item => ({
                        name: item.name,
                        path: path === '/' ? '/' + item.name : path + '/' + item.name,
                        leaf: !item.isDir,
                        isDir: item.isDir
                    })).sort((a, b) => {
                        if (a.isDir && !b.isDir) return -1;
                        if (!a.isDir && b.isDir) return 1;
                        return a.name.localeCompare(b.name);
                    });
                } catch (e) { console.error('ÂàóÂá∫Êñá‰ª∂Â§±Ë¥•:', e); return null; }
            },

            async _getFile(path) {
                // Special handling for .sy files
                if (path.endsWith('.sy')) {
                    const conf = this._parseSyPath(path);
                    if (conf.notebook.closed === false) {
                        const block = await window.pluginSdk.getBlockByID(conf.docId);
                        const markdown = await window.pluginSdk.getMarkdown(conf.docId);
                        const lines = [];
                        if (block) { lines.push('---', 'notebook: ' + conf.notebook.name, 'hpath: ' + block.hpath, '---\n'); }
                        lines.push(markdown);
                        return { name: conf.docId + '.sy', content: lines.join('\n') };
                    }
                }

                const result = await window.pluginSdk.loadBlob(path);
                if (!result.ok) throw new Error('Failed to load Blob from ' + path);
                const blob = result.data;
                const fileName = path.split('/').pop();
                const mime = blob.type || '';

                // Text files
                if (mime.startsWith('text/') || mime === 'application/json' || mime === 'application/javascript' || mime === '' ||
                    /\.(md|txt|json|js|ts|jsx|tsx|css|html|xml|yaml|yml|toml|ini|conf|log|py|java|c|cpp|h|hpp|go|rs|sh|bat)$/i.test(fileName)) {
                    return { name: fileName, content: await blob.text() };
                }

                // Images
                if (mime.startsWith('image/')) {
                    const url = URL.createObjectURL(blob);
                    return { name: fileName, content: '<img src="' + url + '" style="max-width:100%;height:auto;display:block;margin:0 auto;" alt="' + fileName + '">', isHTML: true };
                }

                // Binary
                const fmtSize = (b) => b < 1024 ? b + ' B' : b < 1048576 ? (b / 1024).toFixed(2) + ' KB' : (b / 1048576).toFixed(2) + ' MB';
                return { name: fileName, content: '[‰∫åËøõÂà∂Êñá‰ª∂: ' + fileName + ']\nÁ±ªÂûã: ' + (mime || 'Êú™Áü•') + '\nÂ§ßÂ∞è: ' + blob.size + ' Â≠óËäÇ (' + fmtSize(blob.size) + ')\n\nÊ≠§Êñá‰ª∂Á±ªÂûãÊöÇ‰∏çÊîØÊåÅÈ¢ÑËßà„ÄÇ' };
            },

            _isEditableFile(path) {
                if (path.endsWith('.sy')) return false;
                const fname = path.split('/').pop();
                if (['indexignore', 'syncignore', 'refsearchignore', 'searchignore'].includes(fname)) return true;
                return /\.(txt|md|json|js|ts|jsx|tsx|css|scss|less|html|xml|svg|yaml|yml|toml|ini|conf|log|py|java|c|cpp|h|hpp|go|rs|sh|bat|ps1|rb|php|sql|r|swift|kt|scala|lua|vim|gitignore|env|properties)$/i.test(path);
            },

            async _loadSettings() {
                try { return await window.pluginSdk.loadConfig() || { rootPath: '/data', lastOpenFile: null }; }
                catch (e) { return { rootPath: '/data', lastOpenFile: null }; }
            },
            _saveSettings(s) {
                try { window.pluginSdk.saveConfig(s); } catch (e) { /* ignore */ }
            },

            // ‚îÄ‚îÄ‚îÄ Utilities ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
            _escapeHtml(text) {
                if (!text) return '';
                return text.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
            },

            _toast(message, type = 'info', duration = 3000) {
                const container = this.$refs.toastContainer;
                const icons = { success: '‚úì', error: '‚úï', warning: '‚ö†', info: '‚Ñπ' };
                const el = document.createElement('div');
                el.className = 'toast ' + type;
                el.innerHTML = '<span>' + (icons[type] || '‚Ñπ') + '</span><span>' + this._escapeHtml(message) + '</span>';
                container.appendChild(el);
                setTimeout(() => { el.classList.add('hiding'); setTimeout(() => container.removeChild(el), 300); }, duration);
            }
        };
    }
    </script>
    <!-- Alpine.js: MUST be last script; defer ensures data functions are defined first -->
    <script src="/plugins/sy-f-misc/scripts/alpine.min.js" defer></script>
</body>
</html>
